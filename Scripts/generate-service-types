#!/usr/bin/env python3

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Iterable

import argparse
import csv
import re
import itertools
import urllib.request

ROOT_DIR = Path(__file__).resolve().parent.parent
DOWNLOADS_DIR = ROOT_DIR / 'Downloads'
DNSSERVICEDISCOVERY_SOURCES_DIR = ROOT_DIR / 'Sources' / 'DNSServiceDiscovery'

CACHED_REGISTRY_PATH = DOWNLOADS_DIR / 'service-registry.csv'

@dataclass
class ServiceType:
    name: str
    port: str
    protocol: str
    description: str
    assignee: str

def camel_case(kebab_case: str) -> str:
    segments = kebab_case.split('-')
    return ''.join([segments[0]] + [s.capitalize() for s in segments[1:]])

def fetch_service_types(registry_csv_url: str) -> Iterable[ServiceType]:
    if not CACHED_REGISTRY_PATH.exists():
        CACHED_REGISTRY_PATH.parent.mkdir(parents=True, exist_ok=True)
        with urllib.request.urlopen(registry_csv_url) as u:
            with open(CACHED_REGISTRY_PATH, 'wb') as f:
                f.write(u.read())

    with open(CACHED_REGISTRY_PATH, 'r') as f:
        used = set()
        reader = csv.reader(f)
        for name, port, protocol, description, assignee, *_ in itertools.islice(reader, 1, None):
            if re.fullmatch(r'[a-zA-Z][a-zA-Z0-9\-_]+', name) and protocol:
                key = f'{name}-{protocol}'
                if key not in used:
                    used.add(key)
                    yield ServiceType(
                        name=name,
                        port=port,
                        protocol=protocol,
                        description=description,
                        assignee=assignee,
                    )

def swift_service_type_constant(service_type: ServiceType) -> str:
    return f'public static let `{camel_case(f"{service_type.name}-{service_type.protocol}")}`: Self = "_{service_type.name}._{service_type.protocol}"'

def swift_service_types_extension(registry_csv_url: str, service_types: Iterable[ServiceType]) -> str:
    date = datetime.now().strftime('%Y-%m-%d')
    return '\n'.join([
        f'/// Auto-generated from {registry_csv_url}',
        f'/// on {date}. Please do not edit this file, edit `Scripts/generate-service-types` instead!',
        'extension DNSServiceType {',
        *(line for s in service_types for line in [
            f"    /// {' '.join(s.description.splitlines())} {s.assignee}",
            f'    {swift_service_type_constant(s)}',
        ]),
        '}',
    ])

def main():
    parser = argparse.ArgumentParser(description='Generates Swift definitions of known DNS service types from the IANA registry.')
    parser.add_argument('-r', '--registry-csv-url', default='https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.csv')
    parser.add_argument('-o', '--output', type=Path, default=DNSSERVICEDISCOVERY_SOURCES_DIR / 'DNSServiceType+Generated.swift')

    args = parser.parse_args()

    print('==> Fetching service types...')
    service_types = fetch_service_types(args.registry_csv_url)

    print('==> Generating Swift extension...')
    extension = swift_service_types_extension(
        registry_csv_url=args.registry_csv_url,
        service_types=service_types
    )

    print(f'==> Writing {args.output}')
    with open(args.output, 'w') as f:
        f.write(extension)

if __name__ == '__main__':
    main()
